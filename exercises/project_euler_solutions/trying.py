# I'm going to solve a series of excercises from the website called 'projecteuler.net'
import math





# ---------------------------------------------------------------------------------

    """
        Triangle, pentagonal, and hexagonal numbers are generated by
        the following formulae:

        Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
        Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
        Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
        It can be verified that T285 = P165 = H143 = 40755.

        Find the next triangle number that is also pentagonal and hexagonal.
    """
def exercise3():
    c = int(input("type the amount: "))

    for i in triangle_loop(c):
        #print(i)

        for j in pentagonal_loop(c):
            #print(j)

            for k in hexagonal_loop(c):
                #print(k)
                if i == j and i == k:
                    print(k)
    # listnum = []
    """

    for n in range(2, count + 1):
        T = n * (n + 1) / 2
        for m in range(2, count):
            P = m * (3 * m - 1) / 2
            for l in range(2, count):
                H = l * (2 * l - 1)
                if T == P and T == H:
                    # listnum.append(T)
                    yield T

    counter = 1
    n = 1
    m = 1
    l = 1
    while True:
        T = n * (n + 1) / 2
        P = m * (3 * m - 1) / 2
        H = l * (2 * l - 1)
        if T == P and T == H:
            yield T
            counter = counter + 1
            if counter == 2:
                break

        n = n + 1
        m = m + 1
        l = l + 1
    """

    # print("the numbers that are triangle, pentagonal and hexagonal")
    # print(listnum, sep=",")
def triangle_loop(count):
    for n in range(1, count+1):
        T = n * (n + 1) / 2
        yield T

def pentagonal_loop(count):
    for m in range(1, count+1):
        P = m * (3 * m - 1) / 2
        yield P

def hexagonal_loop(count):
    for l in range(1, count+1):
        H = l * (2 * l - 1)
        yield H



# exercise number 4
# --------------------------------------------------------------------------------------
def f(n, m):
    i = 0
    n_i = 0
    while True:
        L = sumDigit(i)
        if L == n:
            n_i = n_i + 1
            if n_i == m:
                return i
        i = i + 1


def sumDigit(value):
    s = 0
    nstr = str(value)
    for j in range(len(nstr)):
        s = s + int(nstr[j])
    return s


def s(k):
    lst = []
    for n in range(1, k + 1):
        v = f(math.pow(n, 3), math.pow(n, 4))
        lst.append(v)
    absum = math.fsum(lst)
    print(absum)


def stwo(k):
    absum = 0
    for n in range(1, k + 1):
        v = f(math.pow(n, 3), math.pow(n, 4))
        absum = absum + v
    print(absum % 1000000007)


# -----------------------------------------------------------------
def binarySeries():
    pass






# RUN


exercise3()
# exercise4
# print(f(10, 100))
print("-" * 30)
# s(10)
# stwo(3)



"""
problem
"""
import math
def posibilities(to_number):

    for a in range(1, to_number):
        for b in range(1, to_number):
            for c in range(1, to_number):
                if c == math.sqrt(b**2+a**2):
                    p = a+b+c
                    if p == to_number:
                        yield a, b, c

def count_p(ps):
    c = 0
    for k in posibilities(ps):
        print(k)
        c+=1
    return c/2

def require(to):
    lt = []
    n = 1
    while n <=to:
        c = count_p(n)
        print(c)
        lt.append(c)
        n +=1
    return lt

print(max(require(1000)))

                
